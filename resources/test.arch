; single line comments only with ';'
; format as follows: INSTRUCTION_NAME BIT_FORMAT_NAME ARG_N_TYPE ARG_N_ALIAS ARG_N_RANGE 
; register ranges as follows: rN-r(N+X) (ie r0-r13)
; immediate ranges as follows: MIN:MAX (0:255)
; types: REG (registers), IMM (immediates)
; append multiple ranges via '<' between ranges
; memory refs will collapse by compiler!
; bit format as follows: .format NAME OPCODE_LENGTH ARG_N_LENGTH
; max bitwidth set as follow: .bitwidth BITWIDTH
; set instruction arg layouts via: .layout INSTRUCTION_NAME ARG_N_ALIAS (where order HERE determines arg layout)
; .datatype TYPENAME INT_BYTE_LENGTH||"auto"
; beginning!
.bitwidth 16

; formats
.format normal 6 4 3 3
.format imm    6 4 6
.format immS   6 4 1 5
.format large  6 10



; REG related
SGET  imm    REG rd r0-r15 REG rs SPL<IPL<FPL<SPH<IPH<FPH<CR<PR<MR<wL0-wL3<wH0-wH3              ; special get (rs = rd) (L and H means low and high word)
SPUT  imm    REG rs r0-r15 REG rd SPL<IPL<FPL<SPH<IPH<FPH<CR<PR<MR<wL0-wL3<wH0-wH3              ; special put (rs = rd) (L and H means low and high word)
MOV   imm    REG rd r0-r15 REG rs r0-r15                               ; rd = rs
CMOV normal  REG condition 0:15 REG rd r0-r7 REG rs r0-r7              ; if (condition) {rd = rs}
            
; ALU related            
ADD   normal REG rd r0-r15 REG rA r0-r7 REG rB r0-r7                   ; unsigned int add,    rd = rA + rB
SUB   normal REG rd r0-r15 REG rA r0-r7 REG rB r0-r7                   ; unsigned int sub,    rd = rA - rB
ADC   normal REG rd r0-r15 REG rA r0-r7 REG rB r0-r7                   ; unsigned int add,    rd = rA + rB
SBB   normal REG rd r0-r15 REG rA r0-r7 REG rB r0-r7                   ; unsigned int sub,    rd = rA - rB
MUL   normal REG rd r0-r15 REG rA r0-r7 REG rB r0-r7                   ; unsigned int mul,    rd = rA * rB
DIV   normal REG rd r0-r15 REG rA r0-r7 REG rB r0-r7                   ; unsigned int div,    rd = rA / rB
MOD   normal REG rd r0-r15 REG rA r0-r7 REG rB r0-r7                   ; unsigned int modulo, rd = rA % rB
SDIV  normal REG rd r0-r15 REG rA r0-r7 REG rB r0-r7                   ; signed int div,      rd = rA / rB
;SINEG imm    REG rd r0-r15 REG rA r0-r15                               ; signed int negation, rd = -rA DO SOMETHING FOR EXTENDED NEGATION
XOR   normal REG rd r0-r15 REG rA r0-r7 REG rB r0-r7                   ; bitwise XOR,         rd = rA ^ rB
AND   normal REG rd r0-r15 REG rA r0-r7 REG rB r0-r7                   ; bitwise AND,         rd = rA & rB
OR    normal REG rd r0-r15 REG rA r0-r7 REG rB r0-r7                   ; bitwise OR,          rd = rA | rB
NOT   imm    REG rd r0-r15 REG rs r0-r15                               ; bitwise NOT,         rd = ~rs
SHL   normal IMM immediate 0:15 REG rd r0-r7 REG rs r0-r7              ; logical shift left   rd = rs << imm (sets carry flag on bit out)
SHR   normal IMM immediate 0:15 REG rd r0-r7 REG rs r0-r7              ; logical shift right  rd = rs >> imm (sets carry flag on bit out)
SAR   normal IMM immediate 0:15 REG rd r0-r7 REG rs r0-r7              ; arithmeti shit right
ROTL  imm    IMM immediate 0:15 REG rd r0-r7 REG rs r0-r7              ; logical rotate left
ROTR  imm    IMM immediate 0:15 REG rd r0-r7 REG rs r0-r7              ; logical rotate right

; control flow 
HALT 
NOP
;branches
;relative, immediate (add and sub) and (16 and 27 bit reg) (add and sub)
BRIA   imm IMM condition 0:15 IMM immediate 0:63                        ; branch immediate add
BRIS   imm IMM condition 0:15 IMM immediate 0:63                        ; branch immediate sub
BRRA   imm IMM condition 0:15 REG rs r0-r15<SP<IP<FP<CR<PR<MR<w0-w3     ; branch register add
BRRS   imm IMM condition 0:15 REG rs r0-r15<SP<IP<FP<CR<PR<MR<w0-w3     ; branch register sub
;absolute, 16 reg low bit, 27 bit reg full
BRA    imm IMM condition 0:15 REG rs r0-r15<SP<IP<FP<CR<PR<MR<w0-w3     ; branch register set
;jumps
;relative, immediate (add and sub) and (16 and 27 bit reg) (add and sub)
JMPIA  large IMM immediate 0:1023                                       ; jump add immediate
JMPIS  large IMM immediate 0:1023                                       ; jump sub immediate
JMPRA  imm IMM isAbsolute 0:1 REG rs r0-r15<SP<IP<FP<CR<PR<MR<w0-w3     ; jump add/set register
JMPRS  imm IMM isAbsolute 0:1 REG rs r0-r15<SP<IP<FP<CR<PR<MR<w0-w3     ; jump sub/set register
;absolute, 16 reg low bit, 27 bit reg full


;BREL   imm IMM condition 0:15 IMM immediate 0:63                        ; if (cond) {IP + imm} (imm unsigned)
;BBREL  imm IMM condition 0:15 IMM immediate 0:63                        ; if (cont) {IP - imm} (imm unsigned)
;BRELL  imm IMM condition 0:15 REG rs r0-r15<SP<IP<FP<CR<PR<MR<w0-w3     ; if (cond) {IP + rs} (unsigned)
;BBRELL imm IMM condition 0:15 REG rs r0-r15<SP<IP<FP<CR<PR<MR<w0-w3     ; if (cont) {IP - rs} (unsigned)
;JMPR   large IMM immediate 0:1023                                       ; IP + imm (imm unsgned)
;JMPBR  large IMM immediate 0:1023                                       ; IP - imm (imm unsgned) 
;JMPL   imm IMM high_low_set 0:3 REG rs r0-r15<SP<IP<FP<CR<PR<MR<w0-w3   ; IP + rs ()
;JMPBL  imm IMM high_low_set 0:3 REG rs r0-r15<SP<IP<FP<CR<PR<MR<w0-w3   ; IP - rs ()
;JMPH   large REG rs r0-r15<SP<IP<FP<CR<PR<MR<w0-w3                      ; IP = rs (if rs is < 27 bit, then the MSB of IP get set for the bitwidth of rs)
;JMPL   large REG rs r0-r15<SP<IP<FP<CR<PR<MR<w0-w3                      ; IP = rs (if rs is < 27 bit, then the LSB of IP get set for the bitwidth of rs)



RET   large                                                            ; sets SP to FP, pops (what would be IP) into IP, then pops all registers back in
CALL  large REG rs r0-r15<SP<IP<FP<CR<PR<MR<w0-w3                      ; pushes all registers (except IP), pushes IP, sets FP to SP, jumps to address in rs 

; OS related
SIRR              ; software interrupt


; memory related 
LOAD   imm   REG rd r0-r15 REG rs r0-r15<SP<IP<FP<CR<PR<MR<w0-w3         ; rd = memory[rs]
STORE  imm   REG rs r0-r15 REG rd r0-r15<SP<IP<FP<CR<PR<MR<w0-w3         ; memory[rd] = rs
PUSH   large REG rs r0-r15<SP<IP<FP<CR<PR<MR<w0-w3                       ; memory[sp] = rs, sp decrement (push and pop auto manage bit width of register)
POP    large REG rd r0-r15<SP<IP<FP<CR<PR<MR<w0-w3                       ; sp increment, rs = memory[sp] 
MMUF                                                                     ; flush MMU TLB
;-data and instr cache flush/inval isntructions?

; offset in special reg?
; .format .bitwidth .layout - testing line