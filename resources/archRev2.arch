.bitwidth 16

.format normal         6 4  3 3   ; first arg is dest
.format two            6 5  5     ;implies 32 unique registers, first arg is dest
.format immediate      6 4  6     ; first arg is dest
.format smallImmediate 6 3  3 4   ; first arg is dest
.format fullImmediate  6 10 
.format special       6 4 4 2

;normal regs
.reg r0-r15  16 0  ; 16
.reg sp      27 16  ;  1  (32 bits, but only the bottom 27 are read by any instruction) 
.reg fp      27 17  ;  1  (32 bits, but only the bottom 27 are read by any instruction) 
.reg ip      27 18  ;  1  (32 bits, but only the bottom 27 are read by any instruction) 
.reg mem     11 19  ;  1  (16 bits, but only the bottom 11 are read by any instruction) 
.reg w0-w3   32 20  ;  4
.reg wl0-wl3 16 24  ;  4
.reg wh0-wh3 16 28  ;  4

;control regs
.reg ctx     8 0   ;  1
.reg mmio    8 1   ;  1
.reg priv    8 2   ;  1
.reg state  10 3   ;  1
.reg flags   8 4   ;  1


;Arithmetic and logic
  add  2 X normal REG rd r0-r15 REG ra r0-r7 REG rb r0-r7 ;add  
  adc  2 X normal REG rd r0-r15 REG ra r0-r7 REG rb r0-r7  ;add with carry 
  adi  2 X immediate REG rd r0-r15 IMM immediate 0:63 ;add immediate
  adli 4 X two   REG rd r0-r15<wl0-wl3<wh0-wh3  IMM immediate 0:65535  ;add 16 bit immediate

  sub  2 X normal REG rd r0-r15 REG ra r0-r7 REG rb r0-r7                       ;sub 
  sbc  2 X normal REG rd r0-r15 REG ra r0-r7 REG rb r0-r7                        ;sub with carry 
  sbi  2 X immediate REG rd r0-r15 IMM immediate 0:63 ;sub immediate
  sbli 4 X two   REG rd r0-r15<wl0-wl3<wh0-wh3 IMM immediate 0:65535  ;sub 16 bit immediate

  mull 2 X normal REG rd r0-r15 REG ra r0-r7 REG rb r0-r7  
  mulh 2 X normal REG rd r0-r15 REG ra r0-r7 REG rb r0-r7  

  and  2 X normal REG rd r0-r15 REG ra r0-r7 REG rb r0-r7  ;and
  andi 4 X normal REG rd r0-r15 REG ra r0-r7 IMM immediate 0:65535   ;and immediate (stored in next 2 bytes)
  or   2 X normal REG rd r0-r15 REG ra r0-r7 REG rb r0-r7  ;or
  ori  4 X normal REG rd r0-r15 REG ra r0-r7 IMM immediate 0:65535   ;or immediate (stored in next 2 bytes)
  not  2 X normal REG rd r0-r15 REG ra r0-r7  ;not
  xor  2 X normal REG rd r0-r15 REG ra r0-r7 REG rb r0-r7  ;xor
  xori 4 X normal REG rd r0-r15 REG ra r0-r7 IMM immediate 0:65535   ;xor immediate (stored in next 2 bytes)

  shl  2 X normal REG rd r0-r15 REG rA r0-r7 REG rB r0-r7                    ; rd = rA << rB
  shli 2 X smallImmediate REG rd r0-r7 REG rA r0-r7 IMM immediate 0:15       ; rd = rA << immediate
  shr  2 X normal REG rd r0-r15 REG rA r0-r7 REG rB r0-r7                    ; rd = rA >> rB
  shri 2 X smallImmediate REG rd r0-r7 REG rA r0-r7 IMM immediate 0:15       ; rd = rA >> immediate
  ror  2 X normal REG rd r0-r15 REG rA r0-r7 REG rB r0-r7                    ; rotate right
  rori 2 X smallImmediate REG rd r0-r7 REG rA r0-r7 IMM immediate 0:15       ; rotate right immediate

  clz  2 X normal REG rd r0-r15 REG rA r0-r7       ; count leading zeros

  ; #24 instr above

;memory

  ;mode 0: full 2bytes little endian
  ;mode 1: low  byte
  ;mode 2: high byte
  lod   4 X special REG rd r0-r15 REG ra r0-r15 CONST 0     ; rd = [mem << 16 | ra]
  lodl  4 X special REG rd r0-r15 REG ra r0-r15 CONST 1     ; rd = [mem << 16 | ra]
  lodh  4 X special REG rd r0-r15 REG ra r0-r15 CONST 2     ; rd = [mem << 16 | ra]
  sto   4 X special REG rs r0-r15 REG ra r0-r15 CONST 0     ; [mem << 16 ra] = rs
  stol  4 X special REG rs r0-r15 REG ra r0-r15 CONST 1     ; [mem << 16 ra] = rs
  stoh  4 X special REG rs r0-r15 REG ra r0-r15 CONST 2     ; [mem << 16 ra] = rs

  push 2 X two REG rs r0-r15<wl0-wl3<wh0-wh3<w0-w3<mem<sp<ip<fp  ; [sp] = rs, sp -= 2
  pop  2 X two REG rd r0-r15<wl0-wl3<wh0-wh3<w0-w3<mem<sp<ip<fp  ; sp += 2  , rs = [sp]


;moves
  cmov   2 X normal
  swap   2 X two    REG ra r0-r15 REG rb r0-r15 
  mov    2 X two    REG rd r0-r15<wl0-wl3<wh0-wh3<w0-w3<mem<sp<ip<fp REG rs r0-r15<wl0-wl3<wh0-wh3<w0-w3<mem<sp<ip<fp  ;rd = rs (truncates or discards MSB's for mismatched bitwidths)

  movi   2 X two REG rd r0-r15<wl0-wl3<wh0-wh3<w0-w3<mem<sp<ip<fp IMM mode 0:15 
  ; first arg rd, and the 2nd arg describes how the bytes are loaded
  ; modes:
  ; 0 = two bytes (little endian)
  ; 1 = 16 Bus A low byte
  ; 2 = 16 Bus A high byte
  ; 3 = special Bus
  ; 4 = 32 bit bus (4 bytes little endian)
  ; 5 = 32 bit bus lowest byte
  ; 6 = 32 bit bus lower word
  ; 7 = 32 bit bus upper word

  ctlmv  special IMM mode 0:3 REG rN r0-r7 REG rS ctx<mmio<priv<state ;if mode set, then it is storing (otherwise load) TO the control

;control flow
nop  fullImmediate 
halt fullImmediate 
sint fullImmediate 

brc  two       IMM condition 0:15 REG rs r0-r15<wl0-wl3<wh0-wh3<w0-w3<mem<sp<ip<fp      ; branch register
brca immediate IMM condition 0:15 IMM offset 0:63 ; branch add
brcs immediate IMM condition 0:15 IMM offset 0:63 ; branch sub
bala immediate IMM condition 0:15 IMM offset 0:63 ; branch and link add
bals immediate IMM condition 0:15 IMM offset 0:63 ; branch and link sub
balr two       IMM condition 0:15 REG rs r0-r15<wl0-wl3<wh0-wh3<w0-w3<mem<sp<ip<fp      ; branch and link register

jmpa fullImmediate IMM offset 0:1023 ; jump add
jmps fullImmediate IMM offset 0:1023 ; jump sub
jala fullImmediate IMM offset 0:1023 ; jump and link add
jals fullImmediate IMM offset 0:1023 ; jump and link sub
jalr two       REG rs r0-r15<wl0-wl3<wh0-wh3<w0-w3<mem<sp<ip<fp ; jump and link register


;state
sset fullImmediate IMM immediate 0:1023 ;IMM | stateRegister  sets the bits in the immediate
sclr fullImmediate IMM immediate 0:1023 ;~IMM & stateRegister clears the bits in the immediate





; control signals
.ctr 16reg_write                      00   ;
.ctr 16reg_read_a                     01   ;
.ctr 16reg_read_b                     02   ;
.ctr alu_update_flags                 03   ;
.ctr alu_result_to_bus                04   ;if not asserted, it is passthrough
.ctr agu_result_to_bus                05   ;if not asserted, it is passthrough
.ctr agu_flags_to_special_bus         06   ;
.ctr memory_result_to_bus             07   ;  
.ctr icache_inval_address             08   ;
.ctr icache_inval_line                09   ;
.ctr icache_inval_line_set_select     10   ;0 = A, 1 = B
.ctr dcache_flush_address             10   ;
.ctr dcache_flush_line                11   ;
.ctr dcache_inval_address             12   ;
.ctr dcache_inval_line                13   ;
.ctr dcache_inval_line_set_select     14   ;0 = A, 1 = B
.ctr data_translate                   15   ;
.ctr data_passthrough                 16   ;
.ctr data_two_byte                    17   ;
.ctr data_write                       18   ;if not asserted, is data_read
.ctr lower_flag_mask                  19   ;
.ctr mmu_invalidate_page              20   ;
.ctr mmu_invalidate_translation_page  21   ;
.ctr mmu_invalidate_all               22   ;
;.ctr                                  23   ;
;.ctr                                  24   ;